generator client {
  provider        = "prisma-client-js"
  features = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String               @id @default(cuid())
  handle              String               @unique @default(cuid())
  email               String               @unique
  name                String               @default("new_user")
  image               String               @default("https://evame.tech/avatar.png")
  profile             String               @default("")
  twitterHandle       String               @default("")
  plan                String               @default("free")
  totalPoints         Int                  @default(0) @map("total_points")
  isAI                Boolean              @default(false) @map("is_ai")
  provider            String               @default("Credentials")
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  emailVerified       Boolean?
  credential          UserCredential?
  geminiApiKey        GeminiApiKey?
  pages               Page[]
  segmentTranslations SegmentTranslation[]
  translationVotes    TranslationVote[]
  likePages           LikePage[]
  followers           Follow[]             @relation("following")
  following           Follow[]             @relation("follower")
  pageComments        PageComment[]
  accounts            Account[]
  sessions            Session[]
  notifications       Notification[]       @relation("UserNotifications")
  actedNotifications  Notification[]       @relation("NotificationActor")
  translationJobs     TranslationJob[]
  userSettings        UserSetting?

  @@map("users")
}

model UserSetting {
  id            Int      @id @default(autoincrement())
  userId        String   @unique @map("user_id")
  user          User     @relation(fields: [userId], references: [id])
  targetLocales String[] @default([]) @map("target_locales")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@map("user_settings")
}

model UserCredential {
  id       Int    @id @default(autoincrement())
  password String
  userId   String @unique @map("user_id")
  user     User   @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("user_credentials")
}

model GeminiApiKey {
  id     Int    @id @default(autoincrement())
  apiKey String @default("") @map("api_key")
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("gemini_api_keys")
}

model Follow {
  id          Int      @id @default(autoincrement())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")
  follower    User     @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

enum TranslationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

model TranslationJob {
  id     Int  @id @default(autoincrement())
  pageId Int
  // リレーション
  page   Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  userId    String?
  user      User?             @relation(fields: [userId], references: [id])
  locale    String
  aiModel   String
  status    TranslationStatus @default(PENDING)
  progress  Int               @default(0)
  error     String            @default("")
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@index([userId])
}

enum PageStatus {
  DRAFT
  PUBLIC
  ARCHIVE
}

model Page {
  id       Int    @id
  parentId Int?   @map("parent_id")
  parent   Page?  @relation("ParentPage", fields: [parentId], references: [id])
  children Page[] @relation("ParentPage")

  slug  String @unique
  order Int    @default(0)

  mdastJson                   Json                         @map("mdast_json")
  sourceLocale                String                       @default("unknown") @map("source_locale")
  status                      PageStatus                   @default(DRAFT)
  createdAt                   DateTime                     @default(now()) @map("created_at")
  updatedAt                   DateTime                     @updatedAt @map("updated_at")
  content                     Content                      @relation(fields: [id], references: [id], onDelete: Cascade)
  user                        User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                      String                       @map("user_id")
  tagPages                    TagPage[]
  likePages                   LikePage[]
  pageComments                PageComment[]
  notifications               Notification[]
  translationJobs             TranslationJob[]
  pageView                    PageView?
  pageLocaleTranslationProofs PageLocaleTranslationProof[]

  @@index([parentId])
  @@index([createdAt])
  @@index([parentId, order])
  @@index([userId])
  @@index([slug])
  @@map("pages")
}

model PageView {
  pageId Int @id
  count  Int @default(0)

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)
}

enum TranslationProofStatus {
  MACHINE_DRAFT // AI 一次下訳
  HUMAN_TOUCHED // 人手で一部修正
  PROOFREAD // 全文校正（1 人以上）
  VALIDATED // 相互レビュー済（複数人）
}

model PageLocaleTranslationProof {
  id                     Int                    @id @default(autoincrement())
  pageId                 Int                    @map("page_id")
  locale                 String
  translationProofStatus TranslationProofStatus @default(MACHINE_DRAFT) @map("translation_proof_status")
  page                   Page                   @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([pageId, locale])
  @@index([translationProofStatus])
  @@map("page_locale_translation_proofs")
}

model LikePage {
  id        Int      @id @default(autoincrement())
  userId    String?  @map("user_id")
  guestId   String?  @map("guest_id")
  pageId    Int      @map("page_id")
  createdAt DateTime @default(now()) @map("created_at")
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  page      Page     @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([userId, pageId])
  @@unique([guestId, pageId])
  @@index([userId])
  @@index([pageId])
  @@map("like_pages")
}

model Tag {
  id    Int       @id @default(autoincrement())
  name  String    @unique
  pages TagPage[]

  @@index([name])
  @@map("tags")
}

model TagPage {
  tagId  Int
  pageId Int
  tag    Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  page   Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@id([tagId, pageId])
  @@index([tagId])
  @@index([pageId])
  @@map("tag_pages")
}

model PageComment {
  id        Int           @id
  mdastJson Json          @map("mdast_json")
  locale    String
  userId    String        @map("user_id")
  pageId    Int           @map("page_id")
  parentId  Int?          @map("parent_id")
  createdAt DateTime      @default(now()) @map("created_at")
  updatedAt DateTime      @updatedAt @map("updated_at")
  content   Content       @relation(fields: [id], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  page      Page          @relation(fields: [pageId], references: [id], onDelete: Cascade)
  parent    PageComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies   PageComment[] @relation("CommentReplies")

  isDeleted   Boolean   @default(false) @map("is_deleted")
  replyCount  Int       @default(0) @map("reply_count") // 直下の返信数（運用で定義）
  lastReplyAt DateTime? @map("last_reply_at")

  notifications Notification[]

  @@index([pageId, parentId, createdAt])
  @@index([parentId, isDeleted, createdAt])
  @@index([userId])
  @@map("page_comments")
}

model Account {
  id                   String    @id @default(cuid())
  userId               String
  providerId           String    @map("provider")
  accountId            String    @map("providerAccountId")
  refreshToken         String?   @map("refresh_token")
  accessToken          String?   @map("access_token")
  accessTokenExpiresAt DateTime? @map("expires_at")
  scope                String?
  idToken              String?   @map("id_token")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @default(now()) @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  refreshTokenExpiresAt DateTime?
  password              String?

  @@unique([providerId, accountId])
  @@map("accounts")
}

enum NotificationType {
  FOLLOW
  PAGE_COMMENT
  PAGE_LIKE
  PAGE_SEGMENT_TRANSLATION_VOTE
  PAGE_COMMENT_SEGMENT_TRANSLATION_VOTE
}

model Notification {
  id        Int              @id @default(autoincrement())
  userId    String           @map("user_id")
  actorId   String           @map("actor_id")
  type      NotificationType
  read      Boolean          @default(false)
  createdAt DateTime         @default(now()) @map("created_at")

  pageId               Int? @map("page_id")
  pageCommentId        Int? @map("page_comment_id")
  segmentTranslationId Int? @map("segment_translation_id")

  user  User @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  actor User @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)

  page               Page?               @relation(fields: [pageId], references: [id])
  pageComment        PageComment?        @relation(fields: [pageCommentId], references: [id])
  segmentTranslation SegmentTranslation? @relation(fields: [segmentTranslationId], references: [id])

  @@index([userId])
  @@index([actorId])
  @@map("notifications")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")

  ipAddress String?
  userAgent String?

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

enum ContentKind {
  PAGE
  PAGE_COMMENT
}

model Content {
  id        Int         @id @default(autoincrement())
  kind      ContentKind
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  // 各派生（1:1）
  page        Page?
  pageComment PageComment?

  // 子セグメント（1:多）
  segments Segment[]

  importFile ImportFile? @relation(fields: [importFileId], references: [id])
  importFileId Int?      @map("import_file_id")

  @@index([kind])
  @@map("contents")
}

model SegmentType {
  id        Int       @id @default(autoincrement())
  key       String    @unique         // "PRIMARY" | "COMMENTARY" | "GLOSS" など
  label     String                    // 表示名
  weight    Int       @default(0)     // 一括表示時の既定順（任意）

  segments  Segment[]
}

model Segment {
  id        Int     @id @default(autoincrement())
  contentId Int     @map("content_id")
  content   Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  number                Int
  text                  String
  textAndOccurrenceHash String   @map("text_and_occurrence_hash")
  createdAt             DateTime @default(now()) @map("created_at")

  segmentTranslations SegmentTranslation[]
  segmentType         SegmentType          @relation(fields: [segmentTypeId], references: [id])
  segmentTypeId       Int                  @map("segment_type_id")

  linksFrom SegmentLink[] @relation("linksFrom") // 通常: 注側から張る
  linksTo   SegmentLink[] @relation("linksTo") // 通常: 本文側が受ける

  pageBreaks PageBreak[]

  // 1 Owner 内での並びをユニークに
  @@unique([contentId, number])
  @@unique([contentId, textAndOccurrenceHash])
  @@index([contentId])
  @@index([textAndOccurrenceHash])
  @@map("segments")
}

model SegmentLink {
  id Int @id @default(autoincrement())

  // from = 注（COMMENTARY/SUBCOMMENTARY）
  fromSegmentId Int @map("from_segment_id")
  fromSegment   Segment @relation("linksFrom", fields: [fromSegmentId], references: [id])

  // to = 本文（PRIMARY）
  toSegmentId Int @map("to_segment_id")
  toSegment   Segment @relation("linksTo", fields: [toSegmentId], references: [id])


  createdAt DateTime @default(now())

  @@unique([fromSegmentId, toSegmentId])
  @@index([fromSegmentId])
  @@index([toSegmentId])
}
model PageBreak {
  id         Int     @id @default(autoincrement())
  segmentId  Int @map("segment_id")
  segment    Segment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  edition    String   // "PTS" | "VRI" | "Thai" | "Myanmar" | "OUP" …自由
  pageCode   String   @map("page_code") // XMLの n="vol.page" をそのまま（例 "0.0001"）

  createdAt  DateTime @default(now())

  @@index([edition, pageCode])
  @@index([segmentId, edition])
  @@unique([segmentId, edition, pageCode]) // 同じ場所に同じ版ページを二重登録しない
}

model Edition {
  code    String  @id           // "PTS" など（PageBreak.edition と対応）
  label   String
}
model SegmentTranslation {
  id        Int     @id @default(autoincrement())
  segmentId Int     @map("segment_id")
  segment   Segment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  locale    String
  text      String
  point     Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")

  userId        String         @map("user_id")
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifications Notification[]

  votes TranslationVote[]

  @@index([segmentId, locale])
  @@index([userId])
  @@map("segment_translations")
}

model TranslationVote {
  translationId Int      @map("translation_id")
  userId        String   @map("user_id")
  isUpvote      Boolean  @map("is_upvote")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  translation SegmentTranslation @relation(fields: [translationId], references: [id], onDelete: Cascade)
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([translationId, userId]) // 1ユーザー1票
  @@index([translationId])
  @@index([userId])
  @@map("translation_votes")
}

model ImportRun {
  id         Int          @id @default(autoincrement())
  startedAt  DateTime     @default(now()) @map("started_at")
  finishedAt DateTime? @map("finished_at")
  status     String       @default("RUNNING")
  files      ImportFile[]
}

model ImportFile {
  id          Int          @id @default(autoincrement())
  importRunId Int @map("import_run_id")
  importRun   ImportRun    @relation(fields: [importRunId], references: [id], onDelete: Cascade)
  path        String
  checksum    String
  status      String       @default("PENDING")
  message     String       @default("")
  contents    Content[]
  createdAt   DateTime     @default(now())
}
